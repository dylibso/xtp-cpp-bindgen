// THIS FILE WAS GENERATED BY `xtp-cpp-bindgen`. DO NOT EDIT.
#define EXTISM_CPP_IMPLEMENTATION
#include <extism-pdk.hpp>
#include <jsoncons/json.hpp>
#include "pdk.gen.hpp"
#include <magic_enum.hpp>

<% if (usesBuffer(objects)) { -%>
static std::vector<uint8_t> fromJSONToBuffer(const jsoncons::json &val) {
  return val.as<std::vector<uint8_t>>(jsoncons::byte_string_arg,
                                      jsoncons::semantic_tag::base64);
}

static jsoncons::json toJSONFromByteBuffer(const std::vector<uint8_t> &val) {
  return jsoncons::json(jsoncons::byte_string_arg, val,
                        jsoncons::semantic_tag::base64);
}
<% } -%>

<%# encode enums  -%>
<% for (const anEnum of enums) { -%>
JSONCONS_ENUM_TRAITS( <%- 'pdk::'+cppIdentifer(anEnum.name) -%>,
  <%- anEnum.values.join(', ') -%> )
<% } -%>
<%# encode structs  -%>
<% for (const schema of objects) { -%>
<% if (!objectHasBuffer(schema)) { -%>
JSONCONS_ALL_MEMBER_TRAITS( <%- 'pdk::'+cppIdentifer(schema.name) -%>,
  <%- getPropertyNames(schema) -%> )
<% } else {-%>
JSONCONS_ALL_MEMBER_NAME_TRAITS( <%- 'pdk::'+cppIdentifer(schema.name) -%>
<% for (const prop of schema.properties) { -%>
<% if (!isBuffer(prop)) { -%>
, (<%- prop.name -%>, "<%- prop.name -%>")
<% } else {-%>
, (<%- prop.name -%>, "<%- prop.name -%>", JSONCONS_RDWR, jsoncons::always_true(),
     toJSONFromByteBuffer, fromJSONToBuffer)
<% } -%>
<% } -%>
)
<% } -%>
<% } -%>

namespace pdk {

<%# encode exports -%>
namespace exports {
<% for (const func of schema.exports) { %>
int32_t EXTISM_EXPORTED_FUNCTION(<%- func.name -%>) {
  <% if (func.input) { -%>
  <% if (func.input.contentType === 'application/json') { -%>
  extism::log_debug("<%- func.name -%>: getting JSON input");
  auto input_str = extism::input().string();
  if (!input_str.size()) {
    extism::error_set("0 length input cannot be json");
    return -1;
  }
  auto input = jsoncons::decode_json<<%- getJSONDecodeType(func.input) -%>>(std::move(input_str));
  <% if (needsNullCheck(func.input)) { -%>
  if (!input) {
    extism::error_set("null not allowed as input");
    return -2;
  }
  <% } -%>
  <% } else if (isString(func.input)) { -%>
  auto input = extism::input().string();
  <% } else {-%>
  auto input = extism::input<<%- getHandleType(func.input) -%>>().vec();
  <% } -%>
  <% } -%>
  extism::log_debug("<%- func.name -%>: calling implementation function");
  auto result = impl::<%- func.name -%>(<%- func.input ? 'std::move(' + derefIfNotOptionalPointer(func.input) + 'input)' : '' -%>);
  if (!result) {
    extism::error_set("<%- func.name -%>: failed");
    return -3;
  }
  <% if (func.output) { -%>
  <% if (func.output.contentType === 'application/json') { -%>
  <% if (needsNullCheck(func.output)) { -%>
  if (!*result) {
    extism::error_set("null not allowed as output");
    return -4;
  }
  <% } -%>
  extism::log_debug("<%- func.name -%>: setting JSON output");
  std::string output;
  jsoncons::encode_json(*result, output);
  <% } else { -%>
  auto& output = *result;
  <% } -%>
  if (!extism::output<<%- getHandleType(func.output) -%>>(output)) {
    extism::error_set("outputting failed");
    return -5;
  }
  <% } -%>
  extism::log_debug("<%- func.name -%>: returning");
  return 0;
}
<% } -%>

} // namespace exports

namespace imports {

  <% for (const func of schema.imports) { %>
  EXTISM_IMPORT_USER("<%- func.name -%>")
  extern <%- func.output ? 'extism::imports::RawHandle' : 'void' -%>
  <%- func.name -%>(<%- func.input ? 'extism::imports::RawHandle' : '' -%>);
  <% } -%>

} // namespace imports

<% for (const func of schema.imports) { -%>
<%- getImportReturnType(func) -%> <%- func.name-%>(<%- getImportParamType(func) -%> <%- getParamName(func) -%>){
  <% if (func.input) { -%>
  <% if (func.input.contentType === 'application/json') { -%>
  std::string encoded;
  jsoncons::encode_json(input, encoded);
  <% } else if (isEnum(func.input)) { -%>
  auto encoded = magic_enum::enum_name(input);
  <% } else { -%>
  auto& encoded = input;
  <% } -%>
  auto in_handle = extism::UniqueHandle<<%- getHandleType(func.input) -%>>::from(encoded);
  if (!in_handle) {
    return std::unexpected(Error::extism);
  }
  <% } -%>
  <% if (func.output) { -%>
  auto out_raw = imports::<%- func.name-%>(<%- func.input ? '*in_handle' : '' -%> );
  if (!out_raw) {
    return std::unexpected(Error::host_null);
  }
  extism::UniqueHandle<<%- getHandleType(func.output) -%>> out_handle(out_raw);
  <% if (func.output.contentType !== 'application/json') { -%>
  return out_handle.<%- getHandleAccessor(func.output) -%>();
  <% } else { -%>
  auto out_string = out_handle.string();
  if (!out_string.size()) {
    return std::unexpected(Error::not_json);
  }
  <% if (needsNullCheck(func.output)) { -%>
  auto output = jsoncons::decode_json<<%- getJSONDecodeType(func.output)-%>>(std::move(out_string));
  if (!output) {
    extism::error_set("null not allowed as output");
    return std::unexpected(Error::json_null);
  }
  return output;
  <% } else { -%>
  return jsoncons::decode_json<<%- getJSONDecodeType(func.output)-%>>(std::move(out_string));
  <% } -%>
  <% } -%>
  <% } else { -%>
  imports::<%- func.name-%>(<%- func.input ? '*in_handle' : '' -%> );
  <% if (shouldImportReturnExplicitly(func)) { -%>
  return std::expected<void, Error>();
  <% } -%>
  <% } -%>
}

<% } %>

} // namespace pdk
