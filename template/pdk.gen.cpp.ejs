// THIS FILE WAS GENERATED BY `xtp-cpp-bindgen`. DO NOT EDIT.
#define EXTISM_CPP_IMPLEMENTATION
#include "extism-pdk.hpp"
#include "jsoncons/json.hpp"
#include "pdk.gen.hpp"
#include <magic_enum.hpp>

<%# encode enums  -%>
<% for (const schema of enums) { -%>
JSONCONS_ENUM_TRAITS( <%- 'pdk::'+makePublic(schema.name) -%>,
  <%- schema.enum.join(', ') -%> )
<% } -%>
<%# encode structs  -%>
<% for (const schema of objects) { -%>
JSONCONS_ALL_MEMBER_TRAITS( <%- 'pdk::'+makePublic(schema.name) -%>,
  <%- getPropertyNames(schema) -%> )
<% } -%>

namespace pdk {

<%# encode exports -%>
namespace exports {
<% for (const func of schema.exports) { %>
int32_t EXTISM_EXPORTED_FUNCTION(<%- func.name -%>) {
  <% if (func.input) { -%>
  <% if (func.input.contentType === 'application/json') { -%>
  extism::log_debug("<%- func.name -%>: getting JSON input");
  auto input_str = extism::input().string();
  if (!input_str.size()) {
    extism::error_set("0 length input cannot be json");
    return -1;
  }
  auto input = jsoncons::decode_json<<%- getExportJSONDecodeType(func.input) -%>>(std::move(input_str));
  <% } else if (isString(func.input)) { -%>
  auto input = extism::input().string();
  <% } else {-%>
  auto input = extism::input<<%- getHandleType(func.input) -%>>().vec();
  <% } -%>
  <% } -%>
  extism::log_debug("<%- func.name -%>: calling implementation function");
  auto result = impl::<%- func.name -%>(<%- func.input ? 'std::move(' + derefIfNotOptionalPointer(func.input) + 'input)' : '' -%>);
  if (!result) {
    extism::error_set("<%- func.name -%>: failed");
    return -2;
  }
  <% if (func.output) { -%>
  <% if (func.output.contentType === 'application/json') { -%>
  extism::log_debug("<%- func.name -%>: setting JSON output");
  std::string output;
  jsoncons::encode_json(*result, output);
  <% } else { -%>
  auto& output = *result;
  <% } -%>
  if (!extism::output<<%- getHandleType(func.output) -%>>(output)) {
    extism::error_set("outputting failed");
    return -3;
  }
  <% } -%>
  extism::log_debug("<%- func.name -%>: returning");
  return 0;
}
<% } -%>

} // namespace exports

namespace imports {

  <% for (const func of schema.imports) { %>
  EXTISM_IMPORT_USER("<%- func.name -%>")
  extern <%- func.output ? 'extism::imports::RawHandle' : 'void' -%>
  <%- func.name -%>(<%- func.input ? 'extism::imports::RawHandle' : '' -%>);
  <% } -%>

} // namespace imports

<% for (const func of schema.imports) { -%>
<%- getImportReturnType(func) -%> <%- func.name-%>(<%- getImportParamType(func) -%> <%- getParamName(func) -%>){
  <% if (func.input) { -%>
  <% if (func.input.contentType === 'application/json') { -%>
  std::string encoded;
  jsoncons::encode_json(input, encoded);
  <% } else if (isEnum(func.input)) { -%>
  auto encoded = magic_enum::enum_name(input);
  <% } else { -%>
  auto& encoded = input;
  <% } -%>
  auto in_handle = extism::UniqueHandle<<%- getHandleType(func.input) -%>>::from(encoded);
  if (!in_handle) {
    return <%- returnsResult(func) ? 'std::unexpected(Error::extism)': 'nullptr' -%>;
  }
  <% } -%>
  <% if (func.output) { -%>
  auto out_raw = imports::<%- func.name-%>(<%- func.input ? '*in_handle' : '' -%> );
  if (!out_raw) {
    return <%- returnsResult(func) ? 'std::unexpected(Error::host_null)': 'nullptr' -%>;
  }
  extism::UniqueHandle<<%- getHandleType(func.output) -%>> out_handle(out_raw);
  <% if (func.output.contentType !== 'application/json') { -%>
  return out_handle.<%- getHandleAccessor(func.output) -%>();
  <% } else { -%>
  auto out_string = out_handle.string();
  if (!out_string.size()) {
    return <%- returnsResult(func) ? 'std::unexpected(Error::not_json)': 'nullptr' -%>;
  }
  return jsoncons::decode_json<<%- getImportJSONDecodeType(func.output)-%>>(std::move(out_string));
  <% } -%>
  <% } else { -%>
  imports::<%- func.name-%>(<%- func.input ? '*in_handle' : '' -%> );
  <% if (shouldImportReturnExplicitly(func)) { -%>
  return std::expected<void, Error>();
  <% } -%>
  <% } -%>
}

<% } %>

} // namespace pdk
